module wb_interconnect (
    input  logic         clk_i,
    input  logic         rst_n,

    // Master 0 Interface
    input  logic [31:0]  m0_wbd_dat_i,
    input  logic [31:0]  m0_wbd_adr_i,
    input  logic [3:0]   m0_wbd_sel_i,
    input  logic         m0_wbd_we_i,
    input  logic         m0_wbd_cyc_i,
    input  logic         m0_wbd_stb_i,
    output logic [31:0]  m0_wbd_dat_o,
    output logic         m0_wbd_ack_o,
    output logic         m0_wbd_err_o,

    // Master 1 Interface
    input  logic [31:0]  m1_wbd_dat_i,
    input  logic [31:0]  m1_wbd_adr_i,
    input  logic [3:0]   m1_wbd_sel_i,
    input  logic         m1_wbd_we_i,
    input  logic         m1_wbd_cyc_i,
    input  logic         m1_wbd_stb_i,
    output logic [31:0]  m1_wbd_dat_o,
    output logic         m1_wbd_ack_o,
    output logic         m1_wbd_err_o,

    // Slave 0 Interface
    input  logic [31:0]  s0_wbd_dat_i,
    input  logic         s0_wbd_ack_i,
    output logic [31:0]  s0_wbd_dat_o,
    output logic [31:0]  s0_wbd_adr_o,
    output logic [3:0]   s0_wbd_sel_o,
    output logic         s0_wbd_we_o,
    output logic         s0_wbd_cyc_o,
    output logic         s0_wbd_stb_o,

    // Slave 1 Interface
    input  logic [31:0]  s1_wbd_dat_i,
    input  logic         s1_wbd_ack_i,
    output logic [31:0]  s1_wbd_dat_o,
    output logic [31:0]  s1_wbd_adr_o,
    output logic [3:0]   s1_wbd_sel_o,
    output logic         s1_wbd_we_o,
    output logic         s1_wbd_cyc_o,
    output logic         s1_wbd_stb_o
);

    // Internal signals
    logic [1:0]          gnt;           // Grant signals from arbiter
    logic [1:0]          req;           // Request signals to arbiter

    // Master 0 signals
    wire                 m0_req = m0_wbd_cyc_i & m0_wbd_stb_i & ~m0_wbd_ack_o;
    // Master 1 signals
    wire                 m1_req = m1_wbd_cyc_i & m1_wbd_stb_i & ~m1_wbd_ack_o;

    assign req = {m1_req, m0_req};

    // Instantiate the arbiter
    wb_arb u_wb_arb (
        .clk  (clk_i),
        .rstn (rst_n),
        .req  (req),
        .gnt  (gnt)
    );

    // Master multiplexing
    logic [31:0] m_wbd_dat_i;
    logic [31:0] m_wbd_adr_i;
    logic [3:0]  m_wbd_sel_i;
    logic        m_wbd_we_i;
    logic        m_wbd_cyc_i;
    logic        m_wbd_stb_i;
    logic [31:0] m_wbd_dat_o;
    logic        m_wbd_ack_o;
    logic        m_wbd_err_o;

    always_comb begin
        // Default assignments
        m_wbd_dat_i  = 32'b0;
        m_wbd_adr_i  = 32'b0;
        m_wbd_sel_i  = 4'b0;
        m_wbd_we_i   = 1'b0;
        m_wbd_cyc_i  = 1'b0;
        m_wbd_stb_i  = 1'b0;
        m_wbd_dat_o  = 32'b0;
        m_wbd_ack_o  = 1'b0;
        m_wbd_err_o  = 1'b0;

        case (gnt)
            2'b01: begin // Grant to Master 0
                m_wbd_dat_i = m0_wbd_dat_i;
                m_wbd_adr_i = m0_wbd_adr_i;
                m_wbd_sel_i = m0_wbd_sel_i;
                m_wbd_we_i  = m0_wbd_we_i;
                m_wbd_cyc_i = m0_wbd_cyc_i;
                m_wbd_stb_i = m0_wbd_stb_i;
                m0_wbd_dat_o = m_wbd_dat_o;
                m0_wbd_ack_o = m_wbd_ack_o;
                m0_wbd_err_o = m_wbd_err_o;
            end
            2'b10: begin // Grant to Master 1
                m_wbd_dat_i = m1_wbd_dat_i;
                m_wbd_adr_i = m1_wbd_adr_i;
                m_wbd_sel_i = m1_wbd_sel_i;
                m_wbd_we_i  = m1_wbd_we_i;
                m_wbd_cyc_i = m1_wbd_cyc_i;
                m_wbd_stb_i = m1_wbd_stb_i;
                m1_wbd_dat_o = m_wbd_dat_o;
                m1_wbd_ack_o = m_wbd_ack_o;
                m1_wbd_err_o = m_wbd_err_o;
            end
            default: begin
                // No grant
            end
        endcase
    end

    // Address decoding to select the slave
    // For simplicity, we'll assume:
    // Addresses starting with 0x0000_0000 - 0x7FFF_FFFF go to Slave 0
    // Addresses starting with 0x8000_0000 - 0xFFFF_FFFF go to Slave 1

    logic s0_selected = (m_wbd_adr_i[31] == 1'b0);
    logic s1_selected = (m_wbd_adr_i[31] == 1'b1);

    // Connect master to slaves
    // Slave 0
    assign s0_wbd_dat_o = m_wbd_dat_i;
    assign s0_wbd_adr_o = m_wbd_adr_i;
    assign s0_wbd_sel_o = m_wbd_sel_i;
    assign s0_wbd_we_o  = m_wbd_we_i;
    assign s0_wbd_cyc_o = m_wbd_cyc_i & s0_selected;
    assign s0_wbd_stb_o = m_wbd_stb_i & s0_selected;

    // Slave 1
    assign s1_wbd_dat_o = m_wbd_dat_i;
    assign s1_wbd_adr_o = m_wbd_adr_i;
    assign s1_wbd_sel_o = m_wbd_sel_i;
    assign s1_wbd_we_o  = m_wbd_we_i;
    assign s1_wbd_cyc_o = m_wbd_cyc_i & s1_selected;
    assign s1_wbd_stb_o = m_wbd_stb_i & s1_selected;

    // Slave responses back to master
    always_comb begin
        m_wbd_dat_o = 32'b0;
        m_wbd_ack_o = 1'b0;
        m_wbd_err_o = 1'b0;

        if (s0_selected) begin
            m_wbd_dat_o = s0_wbd_dat_i;
            m_wbd_ack_o = s0_wbd_ack_i;
        end else if (s1_selected) begin
            m_wbd_dat_o = s1_wbd_dat_i;
            m_wbd_ack_o = s1_wbd_ack_i;
        end else begin
            m_wbd_err_o = 1'b1; // Invalid address
        end
    end

endmodule
